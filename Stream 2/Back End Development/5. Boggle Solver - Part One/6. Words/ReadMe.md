Words
=====

 

### CONVERTING PATHS TO WORDS

 

A word is generated by following a path through the grid. Let’s write some code
to turn a path (of positions) into a word (of letters). Here’s the test:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def test_converting_a_path_to_a_word(self):
    grid = boggle.make_grid(2, 2)
    oneLetterWord = boggle.path_to_word(grid, [(0, 0)])
    twoLetterWord = boggle.path_to_word(grid, [(0, 0), (1, 1)])
    self.assertEquals(oneLetterWord, grid[(0, 0)])
    self.assertEquals(twoLetterWord, grid[(0, 0)] + grid[(1, 1)])
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

We could create a grid with specific letters, but there’s no need. We’ll see an
example of that later. For now, we’ll create a random grid. The actual letters
don’t matter. We don’t care if these are real words, we just care that we can
turn a list of positions into a string of letters.

 

We can access any letter in the grid by it’s position.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
grid[(0, 0)]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

So our test checks that
the `path_to_word` [function](http://codeinstitute.wpengine.com/glossary/function/) returns
the same strings we manually construct in the test.

 

The code to generate words from paths is really simple:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def path_to_word(grid, path):
    return ''.join([grid[p] for p in path])
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

That’s it. Get the list of letters for the positions in the path, then join them
into a string.

 

### SEARCHING

 

Now things get serious. Given a grid and a list of words, we need to find the
words in the grid. Here’s a test:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def test_search_grid_for_words(self):
    grid = {(0, 0): 'A', (0, 1): 'B', (1, 0): 'C', (1, 1): 'D'}
    twoLetterWord = 'AB'
    threeLetterWord = 'ABC'
    notThereWord = "EEE"
    dictionary = [twoLetterWord, threeLetterWord, notThereWord]
 
    foundWords = boggle.search(grid, dictionary)
 
    self.assertTrue(twoLetterWord in foundWords)
    self.assertTrue(threeLetterWord in foundWords)
    self.assertTrue(notThereWord not in foundWords)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

For this test we create a mock grid, so that we can control the letters. We also
define a dictionary of 3 words. Two are in the grid and should be found. One is
not in the grid and should not be found.

 

Here’s the code to make that test pass:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def search(grid, dictionary):
    neighbours = all_grid_neighbours(grid)
    paths = []
    def do_search(path):
        word = path_to_word(grid, path)
        if word in dictionary:
            paths.append(path)
        for next_pos in neighbours[path[-1]]:
            if next_pos not in path:
                do_search(path + [next_pos])
 
    for position in grid:
        do_search([position])
 
    words = []
    for path in paths:
        words.append(path_to_word(grid, path))
    return set(words)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

There is A LOT going on here, so let’s go through this code in some detail.

 

`Line 1`**:** It’s
a [function](http://codeinstitute.wpengine.com/glossary/function/) that accepts
a grid, and a dictionary. So, it matches the dependencies we identified early on
when we were planning a solution.

 

`Line 2`**:** We get the neighbours of every position in the grid.

 

`Line 3`**:** We’ll use the paths list to capture all paths that form valid
words.

 

You might be wondering why we’re storing words as paths rather than strings. The
reason for this is that a letter could be repeated in the grid several times. If
we had two letter As, and we saved a word with an A in it, how would we know
which A is it?

 

`Lines 4-10`**:** This is an
inner [function](http://codeinstitute.wpengine.com/glossary/function/) that is
called recursively to actually perform a search from a given position. More on
this below.

 

`Line 12-13`**:** For each position in the grid, do a search.

 

`Line 15-18`**:** Convert all the paths that make valid words, into words and
return them in a list.

 

### THE DO\_SEARCH FUNCTION

 

The
inner `do_search` [function](http://codeinstitute.wpengine.com/glossary/function/) above
is a little strange. It’s perfectly valid to nest functions, and in this
instance it’s very handy.
The `do_search` [function](http://codeinstitute.wpengine.com/glossary/function/) exists
within the scope of the
search [function](http://codeinstitute.wpengine.com/glossary/function/). It
can’t be called directly.

 

The `do_search` [function](http://codeinstitute.wpengine.com/glossary/function/) has
access to the other variables defined within search, such as the paths list,
which it can add to.

 

The `do_search` [function](http://codeinstitute.wpengine.com/glossary/function/) can
be called by the
search [function](http://codeinstitute.wpengine.com/glossary/function/), and can
call itself recursively, to build up paths.

 

The
search [function](http://codeinstitute.wpengine.com/glossary/function/) starts a
search by passing a single position to `do_search`. This is a path of 1 letter.
The `do_search` [function](http://codeinstitute.wpengine.com/glossary/function/) converts
whatever path it’s given into a word, and checks if it’s in the dictionary.

 

If the path makes a word, it’s added to the paths list.

 

Whether the path is a word or not, `do_search` gets each of the neighbours of
the last letter, checks to make sure that the neighbouring letter isn’t already
in the path, and then continues the searching from that letter.

 

So, `do_search` could call itself 8 times for a given starting position, and
again for the various neighbours of each neighbour, and so on.

 

### RECURSION

 

Recursion is a topic that strikes fear into the heart of many novice
programmers, but it is actually a very simple and elegant concept.

 

A recursive [function](http://codeinstitute.wpengine.com/glossary/function/) or
data structure is simply one that is defined in terms of itself. In this case we
want to search the neighbours or neighbours of positions. You can imagine a sort
of tree-like search space.

 

Trees or tree-like data structures are the classic example of where recursion
simplifies everything.

 

You can imagine
a [function](http://codeinstitute.wpengine.com/glossary/function/) that searches
a tree. To do so it must search multiple branches. But those branches are merely
smaller trees. So
the [function](http://codeinstitute.wpengine.com/glossary/function/) can pass
the branches it must search to itself so that they can be searched. The end
result being that as those branches split, and so on, all of those splits are
automatically handled by the
search [function](http://codeinstitute.wpengine.com/glossary/function/) treating
each branch the same, and searching it’s children.

 

### THE DICTIONARY

 

We now have a working
search [function](http://codeinstitute.wpengine.com/glossary/function/), but we
want to use a large dictionary of words.

 

We can use a Test to try loading a dictionary file, and checking that it has
contents.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def test_load_dictionary(self):
    dictionary = boggle.get_dictionary('/usr/share/dict/words')
    self.assertGreater(len(dictionary), 0)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### FINDING A DICTIONARY

 

Notice the path passed to
the `get_dictionary` [function](http://codeinstitute.wpengine.com/glossary/function/).
That is the path on `OSX` machines. Your path may be different.

 

Try the following paths, or try searching for ‘`dict`’ or ‘`word`’:

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/share/dict/
/var/lib/dict/
/usr/share/dict/words
/usr/dict/words
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

Alternatively, you can find one
here: [http://www.cs.duke.edu/courses/cps100/spring05/assign/boggle/code/bogwords.txt](http://www.cs.duke.edu/courses/cps100/spring05/assign/boggle/code/bogwords.txt).

 

Just create a new file in your boggle project called `words.txt` and paste in
all the words.

 

Update the path in your test to **‘**`words.txt`**’**.

 

The code to actually load the dictionary file into a list of words is as
follows:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def get_dictionary(dictionary_file):
    with open(dictionary_file) as f:
        return [w.strip().upper() for w in f]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
